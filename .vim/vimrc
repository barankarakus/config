" My Vim configuration!
" It's heavily commented, since I don't trust my future self to remember
" everything.
" If it's not already obvious, use Vim's built-in help command to get more
" info (and more ACCURATE info) on each of the options here

"----- General Tips -----"
" 1. Use Vim's built-in help command (:help <thing>) to get more info (and
"    more ACCURATE info) on stuff done here.
" 2. To check an option's current value: :set <option>? or echo &<option>.
"    To check which file set an option (to its current value): :verbose set <option>?.
"    This will report the file like so: 'Last set by...', unless there was no
"    file that set this option, in which case nothing is said and the option
"    takes on its default value.
" 3. When defining keybindings, ALWAYS use the non-recursive mapping command,
"    i.e. 'noremap', and if your keybinding is to only apply to a single mode or
"    modes, use the corresponding mapping command, e.g. 'nnoremap' for Normal
"    mode. Further, if the keybinding should be local to the buffer in which
"    it's defined (for example, we have an autocmd that runs only for Python
"    files, which defines some keybindings for that file), use <buffer> after
"    the 'map' command, e.g. nnoremap <buffer> <C-J> j.

" not sure exactly what this is for (and I think it's set by default) apparently it's necessary for some other cool stuff; see :h nocompatible for more details 
" HAVE THIS AT THE TOP BECAUSE IT RESETS A BUNCH OF OTHER OPTIONS
set nocompatible            
" setting the location of the viminfo file (storing such things as search history; see :h viminfo) to the same directory as where the vimrc file is stored (this is tracked by the Vim environment variable $MYVIMRC; see :h $MYVIMRC)
let _ = split($MYVIMRC, '/')
let _[-1] = "viminfo"
let _ = join(_, '/')
if $MYVIMRC[0] == '/'       " a '/' at the start of $MYVIMRC gets dropped during the splitting
    let _ = '/' . _         " reminder: '.' is VimScript's string concatenation operator
endif
execute "set viminfo+=n" . _

"----- Leader and Localleader Definitions -----"
let mapleader = ','

" Might change this to something else in future, e.g. "[["?
let maplocalleader = "]" 

"----- Console UI & Text Display -----"

set termguicolors           " enable 24-bit colors (need Terminal to be in 24-bit color too)
                            " keep this at the top of .vimrc because setting it RESETS a bunch of other settings to their default values
set number                  " show line numbers
set cmdheight=1             " explicitly set the height of the command line (1 is default value anyway)
set showcmd                 " show (partial) command (being typed) at command line
                            " REALLY useful: get to see what is typed so far
set scrolloff=5             " keep at least 5 lines around the cursor, if possible

" below settings relate to the display of long lines
set wrap                    " when displaying long lines, soft wrap them (rather than the line trailing off into the abyss...)
if has('linebreak')         " don't just start wrapping at the last character: do it more intelligently, starting at a word
    set linebreak           " but only if this feature exists!
endif

syntax on                   " highlight syntax

" below settings relate to the status and command lines at the bottom of the editor (command line is bottom-most, status line is above that)
set laststatus=2            " necessary for the lightline status bar (see plugins, below) to be displayed all the time (by default, the status line is only displayed under certain circumstances, e.g. when there are multiple buffers open it'll show up)
set noshowmode              " the command line no longer shows the Vim mode (want this because lightline's status bar does) 
set shortmess+=F            " stops the file name from being displayed in the command line bar (want this because lightline's status bar displays this)
set cursorline              " highlight the line the cursor is on (how the highlighting happens depends on the colourscheme)
set wildmenu                " turns on command-line completion when typing Ex commands; just type : followed by some stuff (e.g. 'se') and cycle forward through the possible commands with <Tab> or <Ctrl-H> (or backward with <Ctrl-P>); when you've found the desired match, just continue typing

"----- Text Editing and Searching Behaviour -----"

set hlsearch                " highlight all search results when a pattern has been searched for
                            " once you're done with the search, you might want to remove the highlighting; can do this with the Ex command :noh; the searched pattern is still stored, however, so n or N still work and will reactivate the highlighting
                            " might prefer to define a key binding that will either invoke :noh or will clear the search buffer (Google how do to this)
set ignorecase              " ignore case in search
set smartcase               " unless there's a capital letter in front
set backspace=2             " makes backspace work as expected in Insert mode (like most other text editors)
set autoindent              " enables automatic indenting: if the current line begins with whitespace and we move on to a new line with <Enter>, the new line has the same whitespace
                            " very useful when programming but also with normal text; can turn off in a Vim session with :set noautoindent

"----- Indents and Tabs -----"

set shiftwidth=4            " number of spaces to use for each individual indent; applies to autoindentation and the > and < keys
set softtabstop=-1          " number of spaces that a tab counts for when performing editing operations, e.g. inserting a <Tab>; negative value means the value of 'shiftwidth' is used
set expandtab               " <Tab>s in Insert mode are replaced by actual spaces that achieve the same spacing effect
set shiftround              " round indents created/deleted by < and > keys in Normal mode so that the indentation of a line is always a multiple of the 'shiftwidth' setting
set softtabstop=4           " indentations become 4 spaces

"----- Miscellaneous settings -----"


                                                                  
"----- vim-plug: Listing plug-ins to use -----"
" vim-plug is very lightweight: it's a single file ~/.vim/autload/plug.vim, so it's automatically loaded (as one of the first start-up files) when Vim is fired up
" To install plugins: :PlugInstall
" To clean plugins (e.g. remove plugins not listed here): :CleanPlug

call plug#begin('~/.vim/plugged')           " plugins are downloaded into this directory

Plug 'preservim/nerdtree'                   " file system explorer
Plug 'sonph/onehalf', { 'rtp': 'vim' }      " Makes available the 'onehalfdark', 'onehalflight' colorschemes, also available for the lightline status bar and the terminal (iTerm or MacOS Terminal)
                                            " on that note, the iTerm colorscheme is great
Plug 'itchyny/lightline.vim'                " A configurable statusline for Vim
                                            " I haven't done much configuration, but it looks great out-of-the-box
Plug 'neoclide/coc.nvim'                    " This allows vim to act as a Language Server Protocol (LSP) client,
                                            " which then enables it to communicate with a Language Server (LS)
                                            " via the LSP. The LS provides things like auto-completion, error detection,
                                            " etc. For example, ccls is a LS for C++/C.
                                            " But coc doesn't itself come with any Language Servers. An LS needs to be
                                            " installed or provided separately.
                                            " Roughly, coc works as follows: Say, we've hooked ccls up to coc, and then
                                            " we open a C++ file. Then coc fires up ccls as a separate process, in the background.
                                            " We have a standard client-server set-up: vim/coc acts as the client, and ccls
                                            " as the server. vim/coc sends over our keystrokes, and ccls does all the hard
                                            " work of figuring out any syntax errors, making suggestions for auto-completion,
                                            " etc. The two-way communication is done in accordance with the LSP; in fact,
                                            " this is the very point of the LSP: to standardise the communication between
                                            " text editors and language servers.
                                            " For more details on the LSP and Language Servers, this article is
                                            " enlightening: https://chmanie.com/post/2020/07/17/modern-c-development-in-neovim/

" This function (defined in plug.vim) modifies Vim's runtimepath (see :h runtimepath) to include the directories where the plug-ins, listed above, are installed; for example, if we have Plug 'A/B' above, then the path <plug-in-directory>/A/B is added, where <plug-in-directory> is the directory set within the plug#begin() function. However, it leaves the packpath variable (see :h packpath) alone.
call plug#end()

"----- Settings related to the plug-ins, above -----"
" These need to be placed after the plug#begin()...plug#end() above

" colorscheme to use
" note: the colorscheme for the lightline status bar needs to be set separately. See below.
colorscheme onehalfdark

" Settings related to coc
" -----------------------
" Telling coc to ensure we've got this list of extensions installed; if not, then it'll install them
" for us. 
" The way to directly install coc extensions is to use CocIntall <extension>. But I prefer this since
" I'm making it clear in my vim config exactly which extensions I'm installing.
" coc extensions are (by defualt) stored at ~/.config/coc/extensions/. To see a full list of the extensions,
" and where they live, use :CocList extensions.
" To uninstall coc extensions: CocUninstall <extension>. But note that if the extension is still named
" here, it'll be re-installed the next time coc starts up. So, remove it from this list, too.
" More info: https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions
let g:coc_global_extensions = ['coc-pyright', 'coc-json']
" Turning this on so I can do jump to definitions using the coc plug-in without being prompted to save the changes to the current file
" coc documentation recommends this
set hidden                  
" Setting this to a lower value than the default of 4000 is recommended by the coc documentation because it 'leads to better user experience'.
" from `:h updatetime`, it's clear that updatetime controls the time vim waits (for you to do nothing) before it writes to the .swp file ON DISK.
" I'm guessing that, when working with a language server, it's the changes to the .swp file that are sent to the server; hence, updatetime
" controls how responsive the language server will be to changes you make; however, I'm guessing that setting it to something stupidly low
" might lead to some lag, since the swp file is constantly being written to.
" Thoughts: Keep this at 300 (milliseconds) and change it if the experience isn't good enough
set updatetime=300
" If signcolumn='auto' (the default), then each time the LS spots an error the text is indented and '>>' is shown in red next to the number
" of the line of the error; the text is indented so there's space for the '>>'; this indentation is really annoying because it comes and goes as errors
" appear and are fixed. the solution is to set signcolumn='number' so that when '>>' does appear it just replaces the number of the line
" instead of indenting everything in order to appear to the left of it.
set signcolumn=number

" Configuring the lightline status bar
" ------------------------------------
" Including coc status in it; this shows things like # of errors in the file, if any
" See :h coc-status-lightline
let g:lightline = {
    \ 'colorscheme': 'onehalfdark',
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ],
    \             [ 'cocstatus', 'readonly', 'filename', 'modified' ] ]
    \ },
    \ 'component_function': {
    \   'cocstatus': 'coc#status'
    \ },
    \ }

" ---- Filetype-specific settings ----"
" Make sure these are in autocommand groups (augroup) where the first line is autocmd!
" This ensures that consecutive sourcing of this file does not define the same autocommands multiple times
" Also, make sure to use 'setlocal' where possible, in place of 'set', when
" setting options that should only apply to those filetypes

augroup vim_filetype
    autocmd!
    " Telling vim to not auto-wrap comments as I type them, when working with Vim files
    " (because this file contains many long comments...)
    autocmd FileType vim setlocal fo-=c
augroup END

"----- Key Bindings -----"
" I place these at the end so they take precedence over any keybindings that might have been defined by the plug-ins above 

" making j, k move up one DISPLAY LINE, rather than true line
nnoremap j gj
nnoremap k gk

" for easier switching between multiple open windows: just hold Ctrl and use the usual movement keys h,j,k,l
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

" making capital versions of movement keys h, j, k, l more powerful in Normal,
" Visual, and Operator-Pending modes:
" H moves to start of line, J down half a page, K up half a page, L to end of
" line, with the exception that I don't map J and K in Operator-Pending mode
" since 'half a page' isn't a very precise thing so I don't want to be
" applying operations on such a motion
nnoremap H ^
vnoremap H ^
onoremap H ^
nnoremap L $
vnoremap L $
onoremap L $
nnoremap J <C-D>
vnoremap J <C-D>
nnoremap K <C-U>
vnoremap K <C-U>
" by default, in both of these modes:
" 1. H and L move to the top and bottom of the screen, respectively
" 2. J joins lines and K performs a search for the word the cursor is on (or the text highlighted) using some program (by default, man)
" I don't find these default commands useful APART FROM J, which I do find
" useful, so I map <leader>j to J in these modes
" Note: My leader is [ (at least, at the time of writing) and [j does not do
" anything by default
nnoremap <leader>j J
vnoremap <leader>j J

" escape to Normal mode easier from Insert
inoremap jk <Esc>
" I originally set this to make me stop pressing <Esc> in Insert mode, but I've realised it renders the arrow keys useless (because pressing them sends to Vim the character stream <Esc>OA, <Esc>OB, etc).
"inoremap <Esc> <nop>

" I've remapped J, above, but I find the default action of J (joining the current line to the next) quite useful in general; so, here I re-define it to 

" keybindings related to coc
" --------------------------
" coc doesn't set many (if any) keybindings - has to be done by the user
" Most of the stuff here is adapted from the example configuration provided
" in the coc docs

" Use <Ctrl-Space> to trigger completion when in insert mode.
" Note: Terminal emulators tend to, by default, send the ASCII NUL character when the user enters <Ctrl-Space>; this
" is the same character sent by <Ctrl-@>. To cover both cases, I'm setting keybindings for both.
inoremap <silent><expr> <C-space> coc#refresh()
inoremap <silent><expr> <C-@> coc#refresh()

" For jumping forward and backward between 'diagnostics', i.e. lines with errors
" "down (j) to next error"
nmap <silent> <leader>j <Plug>(coc-diagnostic-next)  
" "up (k) to previous error"
nmap <silent> <leader>k <Plug>(coc-diagnostic-prev)

" For showing documentation for item which cursor is on in a preview window
" This comes from the example vimrc file in the coc documentation
nnoremap <silent> <leader>sd :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  elseif (coc#rpc#ready())
    call CocActionAsync('doHover')
  else
    execute '!' . &keywordprg . " " . expand('<cword>')
  endif
endfunction

" Highlight the symbol and its references when holding the cursor
" This doesn't work for me...? 
autocmd CursorHold * silent call CocActionAsync('highlight')

" Go-to keybindings
" "go-to definition""
nmap <silent> gd <Plug>(coc-definition)
" "go-to implementation"
" not useful for Python (doesn't make any sense), but for C++ it takes us
" to an implementation rather than declaration, if they're in distinct locations
nmap <silent> gi <Plug>(coc-implementation)
" "go-to references"
nmap <silent> gr <Plug>(coc-references)
