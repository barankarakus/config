" My Vim configuration!
" It's heavily commented, since I don't trust my future self to remember
" everything.
" If it's not already obvious, use Vim's built-in help command to get more
" info (and more ACCURATE info) on each of the options here

"----- General Tips -----"
" 1. Use Vim's built-in help command (:help <thing>) to get more info (and
"    more ACCURATE info) on stuff done here.
" 2. To check an option's current value: :set <option>? or echo &<option>.
"    To check which file set an option (to its current value): :verbose set <option>?.
"    This will report the file like so: 'Last set by...', unless there was no
"    file that set this option, in which case nothing is said and the option
"    takes on its default value.
" 3. When defining keybindings, ALWAYS use the non-recursive mapping command,
"    i.e. 'noremap', and if your keybinding is to only apply to a single mode or
"    modes, use the corresponding mapping command, e.g. 'nnoremap' for Normal
"    mode. Further, if the keybinding should be local to the buffer in which
"    it's defined (for example, we have an autocmd that runs only for Python
"    files, which defines some keybindings for that file), use <buffer> after
"    the 'map' command, e.g. nnoremap <buffer> <C-J> j.

" Telling vim to not pretend it's vi (thus enabling vim-specific features)
" HAVE THIS AT THE TOP BECAUSE IT RESETS A BUNCH OF OTHER OPTIONS
set nocompatible            
" If this is vim (and not neovim), set the location of the viminfo file (see :h viminfo) to the same directory
" as where the vimrc file is stored (this is tracked by the vim environment variable $MYVIMRC; see :h $MYVIMRC);
" I do this so as to not pollute my home directory;
" don't need to do this for neovim since neovim doesn't pollute home anyway
if !has('nvim')
    let _ = split($MYVIMRC, '/')
    let _[-1] = "viminfo"
    let _ = join(_, '/')
    if $MYVIMRC[0] == '/'       " a '/' at the start of $MYVIMRC gets dropped during the splitting
        let _ = '/' . _         " reminder: '.' is VimScript's string concatenation operator
    endif
    execute "set viminfo+=n" . _
endif

"----- Leader and Localleader Definitions -----"
let mapleader = ','

" Might change this to something else in future, e.g. "[["?
let maplocalleader = "]" 

"----- Console UI & Text Display -----"

set termguicolors           " enable 24-bit colors (need Terminal to be in 24-bit color too)
                            " keep this at the top of .vimrc because setting it RESETS a bunch of other settings to their default values
set number                  " show line numbers
set cmdheight=1             " explicitly set the height of the command line (1 is default value anyway)
set showcmd                 " show (partial) command (being typed) at command line
                            " REALLY useful: get to see what is typed so far
set scrolloff=5             " keep at least 5 lines around the cursor, if possible

" below settings relate to the display of long lines
set wrap                    " when displaying long lines, soft wrap them (rather than the line trailing off into the abyss...)
if has('linebreak')         " don't just start wrapping at the last character: do it more intelligently, starting at a word
    set linebreak           " but only if this feature exists!
endif

syntax on                   " highlight syntax

" below settings relate to the status and command lines at the bottom of the editor (command line is bottom-most, status line is above that)
set laststatus=2            " necessary for the lightline status bar (see plugins, below) to be displayed all the time (by default, the status line is only displayed under certain circumstances, e.g. when there are multiple buffers open it'll show up)
set noshowmode              " the command line no longer shows the Vim mode (want this because lightline's status bar does) 
set shortmess+=F            " stops the file name from being displayed in the command line bar (want this because lightline's status bar displays this)
set cursorline              " highlight the line the cursor is on (how the highlighting happens depends on the colourscheme)
set wildmenu                " turns on command-line completion when typing Ex commands; just type : followed by some stuff (e.g. 'se') and cycle
                            " forward through the possible commands with <Tab> or <Ctrl-H> (or backward with <Ctrl-P> or <Shift-Tab>); when you've
                            " found the desired match, just continue typing

"----- Text Editing and Searching Behaviour -----"

set hlsearch                " highlight all search results when a pattern has been searched for
                            " once you're done with the search, you might want to remove the highlighting; can do this with the Ex command :noh; the searched pattern is still stored, however, so n or N still work and will reactivate the highlighting
                            " might prefer to define a key binding that will either invoke :noh or will clear the search buffer (Google how do to this)
set ignorecase              " ignore case in search
set smartcase               " unless there's a capital letter in front
set backspace=2             " makes backspace work as expected in Insert mode (like most other text editors)
set autoindent              " enables automatic indenting: if the current line begins with whitespace and we move on to a new line with <Enter>, the new line has the same whitespace
                            " very useful when programming but also with normal text; can turn off in a Vim session with :set noautoindent

"----- Indents and Tabs -----"

set shiftwidth=4            " number of spaces to use for each individual indent; applies to autoindentation and the > and < keys
set softtabstop=-1          " number of spaces that a tab counts for when performing editing operations, e.g. inserting a <Tab>; negative value means the value of 'shiftwidth' is used
set expandtab               " <Tab>s in Insert mode are replaced by actual spaces that achieve the same spacing effect
set shiftround              " round indents created/deleted by < and > keys in Normal mode so that the indentation of a line is always a multiple of the 'shiftwidth' setting
set softtabstop=4           " indentations become 4 spaces

"----- Miscellaneous settings -----"
                                                                
"----- vim-plug: Listing plug-ins to use -----"
" vim-plug is very lightweight: it's a single file ~/.vim/autload/plug.vim, so it's automatically loaded (as one of the first start-up files) when Vim is fired up
" To install plugins: :PlugInstall
" To clean plugins (e.g. remove plugins not listed here): :CleanPlug

call plug#begin('~/.vim/plugged')           " plugins are downloaded into this directory

Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
Plug 'airblade/vim-rooter'
Plug 'preservim/nerdtree'
Plug 'itchyny/lightline.vim'
" One-stop shop for 'language packs', i.e. syntax highlighting and indentation support for various filetypes
Plug 'sheerun/vim-polyglot'
" Epic colorscheme
Plug 'tomasr/molokai'
" Ones for the future
" Plug 'tpope/vim-fugitive'
" Plug 'tpope/vim-surround'
" For easily commenting/uncommenting across various filetypes
Plug 'tpope/vim-commentary'
Plug 'neoclide/coc.nvim'                    " This allows vim to act as a Language Server Protocol (LSP) client,
                                            " which then enables it to communicate with a Language Server (LS)
                                            " via the LSP. The LS provides things like auto-completion, error detection,
                                            " etc. For example, ccls is a LS for C++/C.
                                            " But coc doesn't itself come with any Language Servers. An LS needs to be
                                            " installed or provided separately.
                                            " Roughly, coc works as follows: Say, we've hooked ccls up to coc, and then
                                            " we open a C++ file. Then coc fires up ccls as a separate process, in the background.
                                            " We have a standard client-server set-up: vim/coc acts as the client, and ccls
                                            " as the server. vim/coc sends over our keystrokes, and ccls does all the hard
                                            " work of figuring out any syntax errors, making suggestions for auto-completion,
                                            " etc. The two-way communication is done in accordance with the LSP; in fact,
                                            " this is the very point of the LSP: to standardise the communication between
                                            " text editors and language servers.
                                            " For more details on the LSP and Language Servers, this article is
                                            " enlightening: https://chmanie.com/post/2020/07/17/modern-c-development-in-neovim/

" This function (defined in plug.vim) modifies Vim's runtimepath (see :h runtimepath) to include the directories where the plug-ins, listed above, are installed; for example, if we have Plug 'A/B' above, then the path <plug-in-directory>/A/B is added, where <plug-in-directory> is the directory set within the plug#begin() function. However, it leaves the packpath variable (see :h packpath) alone.
call plug#end()

" Switching vim-rooter off.
let g:rooter_manual_only = 1
set noautochdir  " This messes with things

" Versions of fzf.vim's `Rg`, `Files` commands which launch from the project
" root of the current buffer, as defined by vim-rooter's `FindRootDirectory`
" function.
" The only difference from the default versions of the commands: here, I
" supply fzf#vim#with_preview a Dict providing the project directory.
" When vim-rooter can't find a project root, `FindRootDirectory` outputs the
" empty string. In this case, the below commands behaves identically to their
" default versions: they launch from vim's current directory.
command! -bang -nargs=? -complete=dir ProjectFiles
  \ call fzf#vim#files(
  \   FindRootDirectory(),
  \   <bang>0
  \ )

command! -bang -nargs=* ProjectRg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --no-heading --color=always --smart-case -- '.shellescape(<q-args>),
  \   1,
  \   fzf#vim#with_preview({'dir': FindRootDirectory()}),
  \   <bang>0
  \ )

"----- Settings related to the plug-ins, above -----"
" These need to be placed after the plug#begin()...plug#end() above

" vim-rooter settings
let g:rooter_patterns = ['.git', '.ccls']

" colorscheme to use
" note: the colorscheme for the lightline status bar needs to be set separately. See below.
colorscheme molokai

" Settings related to coc
" -----------------------
" Telling coc to ensure we've got this list of extensions installed; if not, then it'll install them
" for us. 
" The way to directly install coc extensions is to use CocIntall <extension>. But I prefer this since
" I'm making it clear in my vim config exactly which extensions I'm installing.
" coc extensions are (by defualt) stored at ~/.config/coc/extensions/. To see a full list of the extensions,
" and where they live, use :CocList extensions.
" To uninstall coc extensions: CocUninstall <extension>. But note that if the extension is still named
" here, it'll be re-installed the next time coc starts up. So, remove it from this list, too.
" More info: https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions
let g:coc_global_extensions = ['coc-pyright', 'coc-json']
" Turning this on so I can do jump to definitions using the coc plug-in without being prompted to save the changes to the current file
" coc documentation recommends this
set hidden                  
" Setting this to a lower value than the default of 4000 is recommended by the coc documentation because it 'leads to better user experience'.
" from `:h updatetime`, it's clear that updatetime controls the time vim waits (for you to do nothing) before it writes to the .swp file ON DISK.
" I'm guessing that, when working with a language server, it's the changes to the .swp file that are sent to the server; hence, updatetime
" controls how responsive the language server will be to changes you make; however, I'm guessing that setting it to something stupidly low
" might lead to some lag, since the swp file is constantly being written to.
" Thoughts: Keep this at 300 (milliseconds) and change it if the experience isn't good enough
set updatetime=300
" If signcolumn='auto' (the default), then each time the LS spots an error the text is indented and '>>' is shown in red next to the number
" of the line of the error; the text is indented so there's space for the '>>'; this indentation is really annoying because it comes and goes as errors
" appear and are fixed. the solution is to set signcolumn='number' so that when '>>' does appear it just replaces the number of the line
" instead of indenting everything in order to appear to the left of it.
set signcolumn=number

" Configuring the lightline status bar
" ------------------------------------
" Including coc status in it; this shows things like # of errors in the file, if any
" See :h coc-status-lightline
let g:lightline = {
    \ 'colorscheme': 'molokai',
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ],
    \             [ 'cocstatus', 'readonly', 'filename', 'modified' ] ]
    \ },
    \ 'component_function': {
    \   'cocstatus': 'coc#status'
    \ },
    \ }

" ---- Filetype-specific settings ----"
" Make sure these are in autocommand groups (augroup) where the first line is autocmd!
" Why? Placing an autocmd definition inside an augroup essentially just assigns that autocommand
" a label: the name of the autocommand group. Whenever you run autocmd! within an augroup block,
" any autocmds that come under that group are purged (i.e. removed).
" Thus, writing autocmds in augroups and having autocmd! as the first line of an augroup ensures
" that consecutive sourcing of the vimrc file does not define the same autocommands multiple times.
" Also, make sure to use 'setlocal' where possible - in place of 'set' - when
" setting options that should only apply to those filetypes.

augroup vim_filetype
    autocmd!
    " Telling vim to not auto-wrap comments as I type them, when working with Vim files
    " (because this file contains many long comments...)
    autocmd FileType vim setlocal fo-=c
augroup END

augroup c_and_cpp_filetype
    autocmd!
    " The default commentstring is "/* %s */", where %s is the content of some line
    " I'm changing this to "// %s"
    autocmd FileType cpp setlocal commentstring=//\ %s
    autocmd FileType c setlocal commentstring=//\ %s
augroup END

"----- Key Bindings -----"
" I place these at the end so they take precedence over any keybindings that might have been defined by the plug-ins above 

" making j, k move up one DISPLAY LINE, rather than true line
nnoremap j gj
nnoremap k gk

" Visual, and Operator-Pending modes:
" H moves to start of line, J down half a page, K up half a page, L to end of
" line, with the exception that I don't map J and K in Operator-Pending mode
" since 'half a page' isn't a very precise thing so I don't want to be
" applying operations on such a motion
nnoremap H ^
vnoremap H ^
onoremap H ^
nnoremap L $
vnoremap L $
onoremap L $
nnoremap J <C-D>
vnoremap J <C-D>
nnoremap K <C-U>
vnoremap K <C-U>
" by default, in both of these modes:
" 1. H and L move to the top and bottom of the screen, respectively
" 2. J joins lines and K performs a search for the word the cursor is on (or the text highlighted) using some program (by default, man)
" I don't find these default commands useful APART FROM J, which I do find
" useful, so I map <leader>j to J in these modes
" Note: My leader is [ (at least, at the time of writing) and [j does not do
" anything by default
nnoremap <leader>j J
vnoremap <leader>j J

" escape to Normal mode easier from Insert
inoremap jk <Esc>
" I originally set this to make me stop pressing <Esc> in Insert mode, but I've realised it renders the arrow keys useless (because pressing them sends to Vim the character stream <Esc>OA, <Esc>OB, etc).
"inoremap <Esc> <nop>

" Tab Management/Navigation 
" Kind of a hack to get <Ctrl-Alt-h> and <Ctrl-Alt-l> to move left/right in
" tab-bar, and <Ctrl-Alt-j>, <Ctrl-Alt-k> to move the current tab left/right,
" and make it all work in a terminal window
" œ was originally <Alt-q>; map <Ctrl-Alt-h> to this on iTerm end
nnoremap<silent> œ :tabprev<CR>
inoremap<silent> œ :<Esc>:tabprev<CR>
tnoremap<silent> œ <C-W>N:tabprev<CR>
" Œ was originally <Alt-Shift-q>; map <Ctrl-Alt-l> to this on iTerm end
nnoremap<silent> Œ :tabnext<CR>
inoremap<silent> Œ <Esc>:tabnext<CR>
tnoremap<silent> Œ <C-W>N:tabnext<CR>
" vim's native tabmove function doesn't wrap around, so here's a workaround
" @param direction -1 for left, 1 for right.
function! TabMove(direction)
    let s:current_tab=tabpagenr()
    let s:total_tabs = tabpagenr("$")
    " Wrap to end
    if s:current_tab == 1 && a:direction == -1
        tabmove
    " Wrap to start
    elseif s:current_tab == s:total_tabs && a:direction == 1
        tabmove 0
    " Normal move
    else
        execute (a:direction > 0 ? "+" : "-") . "tabmove"
    endif
endfunction
" ® was originally <Alt-r>; map <Ctrl-Alt-Shift-h> to this on iTerm end
nnoremap<silent> ® :call TabMove(-1)<CR>
inoremap<silent> ® <C-o>:call TabMove(-1)<CR>
tnoremap<silent> ® <C-W>N:call TabMove(-1)<CR>i
" Â was originally <Alt-R>; map <Ctrl-Alt-Shift-l> to this on iTerm end
nnoremap<silent> Â :call TabMove(1)<CR>
inoremap<silent> Â <C-o>:call TabMove(1)<CR>
tnoremap<silent> Â <C-W>N:call TabMove(1)<CR>i
" New tab creation and current tab closing
nnoremap<silent> <C-N> :tabnew<CR>
inoremap<silent> <C-N> <Esc>:tabnew<CR>
nnoremap<silent> <C-Q> :tabclose<CR>
inoremap<silent> <C-Q> <Esc>:tabclose<CR>


" Better tabbing
vnoremap > >gv
vnoremap > <gv

" Quicker window navigation
nnoremap <C-H> <C-W>h
nnoremap <C-J> <C-W>j
nnoremap <C-K> <C-W>k
nnoremap <C-L> <C-W>l
tnoremap <C-H> <C-W>h
tnoremap <C-J> <C-W>j
tnoremap <C-K> <C-W>k
tnoremap <C-L> <C-W>l

" Window resizing
" Same 'hack' as above: co-ordinating vim and iTerm together to get the
" desired effects
" Mapping <Alt-=> to horizontal size increase
nnoremap<silent> ≠ :vertical resize +2<CR>
" Mapping <Alt--> to horizontal size decrease
" æ was originally <Alt-'>; map <Alt--> to this on iTerm end
nnoremap<silent> æ :vertical resize -2<CR>
" Mapping <Alt-Shift-=> to vertical size increase
nnoremap<silent> ± :resize +2<CR>
" Mapping <Alt-Shift--> to vertical size decrease
" Æ was originally <Alt-Shift-'>; map <Alt--> to this on iTerm end
nnoremap<silent> Æ :resize -2<CR>

" Allow mouse use?
" set mouse=a
            
" keybindings related to coc
" --------------------------
" coc doesn't set many (if any) keybindings - has to be done by the user
" Most of the stuff here is adapted from the example configuration provided
" in the coc docs

" Use <Ctrl-Space> to trigger completion when in insert mode.
" Note: Terminal emulators tend to, by default, send the ASCII NUL character when the user enters <Ctrl-Space>; this
" is the same character sent by <Ctrl-@>. To cover both cases, I'm setting keybindings for both.
inoremap <silent><expr> <C-space> coc#refresh()
inoremap <silent><expr> <C-@> coc#refresh()

" For jumping forward and backward between 'diagnostics', i.e. lines with errors
nmap <silent> [g <Plug>(coc-diagnostic-next)  
nmap <silent> ]g <Plug>(coc-diagnostic-prev)

" For showing documentation for item which cursor is on in a preview window
" This comes from the example vimrc file in the coc documentation
nnoremap <silent> <leader>sd :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  elseif (coc#rpc#ready())
    call CocActionAsync('doHover')
  else
    execute '!' . &keywordprg . " " . expand('<cword>')
  endif
endfunction

" Highlight the symbol and its references when holding the cursor
" This doesn't work for me...? 
autocmd CursorHold * silent call CocActionAsync('highlight')

" Go-to keybindings
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nmap <silent> gy <Plug>(coc-type-definition)

" When seleting among auto-complete suggestions, let <CR> (<Enter>) select
" the highlighted completion item (as opposed to literally entering <Enter>);
" by default, the way to 'select' the highlighted item is to simply continue
" typing normally, but I like confirming my selection with <Enter>
inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
