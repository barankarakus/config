# Setting up zsh Vim emulation.
# -----------------------------

# Telling zsh to use vi mode (technically, telling the ZLE to use the
# 'viins' keymap by default; see below...)
bindkey -v

# Defining a new 'no-op' function/widget, doing nothing
# I don't use this but keeping it here for illustrative purposes
zsh-widget-noop () {}
zle -N zsh-widget-noop  # Allow the function to be a ZLE widget

# By default, '^J' is mapped to the widget 'accept-line', which is exactly
# the effect of pressing Enter (Carriage Return): the text in the output
# buffer is sent to be interpreted by zsh, and our command prompt moves 
# down a line. I can tell this from the output of `bindkey '^J'`.
# Here's the thing. '^J' represents 'newline'. Below, we tell zsh that
# when it receives '^J', it should instead invoke the widget 'self-insert',
# so that the key '^J' (i.e. a new line) is inserted into the buffer.
bindkey '^J' self-insert
# Okay, cool, but for this to be usable we need our terminal emulator to be
# able to send the key sequence '^J' to zsh.
# By default, this is exactly what <Ctrl-J> will send.
# Instead, I want <Shift-Enter> to send this (indeed, the whole point of what
# I'm doing here is to enable me to take a new line with <Shift-Enter>).
# Thus, we have to mess around with our terminal emulator's settings to force
# it to send this key sequence upon <Shift-Enter>. I've figured out that in iTerm
# the way to do this is to go to Profiles > Keys > + > And map <Shift-Return>
# to the action 'Send Hex Codes', the hex code to send being 0xa. Alternatively,
# select the action 'Send Text with "vim" Special Chars' and type in \<C-J>
# as the text to send; this has the same effect but is more readable.

# Note that zsh (and other shells) *do not* receive input direectly from your
# keyboad. Your keyboard gives input to the *terminal*, which *then* converts
# your key presses into key sequences, which it sends over to the shell.
# Thus, the shell takes in not your key presses but the key sequences that your
# terminal converted them into.
# So, when we're binding '^J' to self-insert, above, we're telling zsh
# what to do NOT when we type '^J' but rather when it receives the key
# sequence '^J' (which our terminal transforms <Ctrl-J> into).
# When trying to make keyboard actions do certain things in zsh, we need to
# ask:
# What key sequence does the terminal map that keyboard action to?
# Once we know the answer to this, we know what key sequence to map
# on the shell's end.
# To figure this out, press <Ctrl-V> to activate 'quoted insert' (see
# `bindkey '^V'` and the quoted-insert ZLE widget, then do the keyboard 
# action. This 'quoted insert' mode of the shell makes it print the raw 
# key sequences it receives, rather than interpreting them (i.e. it temporarily disables all
# key sequence mappings). So, we can directly see the key sequence
# printed.

# Using 'jk' typed in quick succession to Esc to Normal mode from Insert
bindkey -M viins 'jk' vi-cmd-mode

# Mapping <Ctrl-K> and <Ctrl-J> to do nothing in Normal mode,
# because I find myself accidentally pressing them (I'm confusing
# them for <Cmd-K>, <Cmd-J>, which I've set up to move up and down
# within iTerm panes)

# Mapping H, L to what they're mapped to in my .vimrc,
# i.e H takes us to first non-blank character in line (alias for ^),
# L to end of line (alias for $)
bindkey -M vicmd 'H' vi-first-non-blank
bindkey -M vicmd 'L' vi-end-of-line

# Mapping <Ctrl-P> and <Ctrl-N> to what one expects: going up and down history.
# By default, this works in Normal mode but not in Insert mode.
bindkey '^P' up-history
bindkey '^N' down-history

# Mapping : so that while in 'Command mode', it does nothing, because: 
# 1) No such thing as Ex mode here, and
# 2) : is opening up a prompt to type a ZLE command, and I don't see a
# use for any of these.
bindkey -M vicmd ':' vi-cmd-mode

# Mapping backspace so that while in 'Insert mode', it works like you'd bloody expect: Deletes the character before the cursor. By default, it doesn't let you delete before the point at which you entered Insert mode (????).
# This 'backward-delete-char' widget also allows us to backspace through new lines.
# The zsh ZLE documentation says \b represents the backspace key, and ^?
# represents 'delete'; I've got both here because the first line didn't do the
# job (but it might on other systems?) and the second did.
bindkey -M viins '\b' backward-delete-char
bindkey -M viins '^?' backward-delete-char

# Documentation on zsh key mappings here:
# http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html.
# Equivalently, check the man page for zshzle.
# It's quite hard to read... 
# In a Nutshell, ZLE is the Zsh Line Editor: it's what we type stuff into.
# There are several 'keymaps', which are distinct collections of key bindings.
# Think of these keymaps as *modes* (like Vim modes!) which ZLE can be in; it
# switches between them by selecting which keymap is in use.
# There are keymaps corresponding to Vim modes: viins for Insert, vicmd for 
# Command (basically also Normal), visual for, well, visual, etc.
# The bindkey command manipulates keymaps and key bindings - it lets us define
# key bindings. The -M option specifies the keymap to modify. What follows
# is the keys to map - written as a string - and then the command (or 'widget',
# in the language of the documentation) to map to.
# Later on in the documenation, under 'Standard Widgets', many of the possible
# 'commands' - or 'widgets' - are listed, as well as which (sequence of) keys
# map to them and in which modes, by default. It is from this list that I've
# found the above commands, like 'vi-cmd-mode' (which takes us to command mode).

# Here's a Git repo of some-one else's dot files - they have lots of Vim
# key-bindings for zsh: https://github.com/mkomitee/dotfiles. Good to look at
# for inspiration and for an understanding of how to define key bindings for
# zsh.
# -----------------------------

# Setting up zsh to invoke Vim's built-in manpager for viewing man pages
# ----------------------------------------------------------------------
# Two benefits:
# 1) man pages are syntax highlighted - as if they needed to be more fun to
# read :)
# 2) man pages are opened up in Vim - so all my keybindings apply

# Originally, I had the following line, obtained from :help man and :help manpager within Vim:
# export MANPAGER="vim -M +MANPAGER -"
# This works fine but has one problem: Once you open a man page and then quit, you see
# "Reading from stdin..." printed at the command-line - very annoying.
# Here's a fix obtained from https://vi.stackexchange.com/questions/4682/how-can-i-suppress-the-reading-from-stdin-message-from-within-vim:
export MANPAGER='bash -c "vim -MRn -c \"set ft=man nomod nolist nospell nonu\" -c \"nm q :qa!<CR>\" -c \"nm <end> G\" -c \"nm <home> gg\"</dev/tty <(col -b)"'
